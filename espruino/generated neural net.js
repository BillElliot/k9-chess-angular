/*
This simple program calculates the x and y co-ordinates
of the ultrasonic transmitter relative to the centre of
the robot.  It uses a standalone feed forward neural net
generated by the Synaptic.JS library.

It captures the data from the five ultrasonic sensors
and uses the neural net to calculate three values between
zero and one.  These are then translated to the sine, cosine and
distance of the transmitter.

Simple trigonometry is then used to translate those values
to x and y co-ordinates.

Published under Creative Commons
Richard Hopkins, 12th October 2017
*/
function (input) {
F = {
0: 0.16528572518,
1: 0.16699473563,
2: 0.19824521248,
3: 0.19336232547,
4: 0.15991454947,
13: 0.8932046931895035,
5: 1.7847067482038588,
6: 2.123901792468171,
7: -35.90827869164514,
8: 68.16002491856413,
9: 19.679127376567674,
10: 3.4291644194136164,
11: 89.4106961356289,
12: 34.472483402929754,
14: 0.09539006925374845,
58: -21.945141329704754,
68: -7.040865768744483,
78: -1.5000704306954435,
23: 0.9073504455064301,
15: 1.7051128767325263,
16: 2.2817046099866194,
17: -28.77104743984869,
18: 43.72362935353154,
19: 1.4127237744201968,
20: 87.41079249552176,
21: 0.48639559907242863,
22: 38.559700107890215,
24: 0.08406561454571294,
59: 20.749926854915866,
69: -5.703976090729581,
79: -3.6947897773330802,
33: 0.7365460929145874,
25: 0.971014107539875,
26: 1.0280933906628542,
27: 32.76651909221584,
28: -149.75223065722227,
29: -78.93971528453746,
30: -4.325653240247082,
31: 0.391635118645311,
32: 43.63778415344155,
34: 0.19404594592684338,
60: -4.214589549036702,
70: -6.75989422197201,
80: 0.353125540117511,
43: 0.9138069113725101,
35: 2.2606694512316934,
36: 2.3610292963124633,
37: -4.6254624603393895,
38: 0.4321294395493321,
39: 10.462152686114322,
40: -1.28954086594442,
41: 27.839761162958904,
42: 0.2551368421005903,
44: 0.07876384010034354,
61: -9.909990659029626,
71: 7.657495277252159,
81: -2.1384426672987393,
53: 0.5130552592525597,
45: 0.057831708754288336,
46: 0.05223290925742319,
47: -12.32849003526486,
48: 53.3112174468019,
49: 46.93450002541289,
50: 3.933893140800955,
51: -1.3610059244239483,
52: -29.921738457515236,
54: 0.24982956020584846,
62: -3.234370678324734,
72: -2.8435237716709016,
82: 0.42830345699084077,
63: 0.5035156049687228,
55: -0.32130179138580495,
56: 0.014062651620663225,
57: 14.605665153004754,
64: 0.24998764052170389,
73: 0.3285535310819797,
65: -0.09546114827149688,
66: -0.7147345133646377,
67: 10.189854736303543,
74: 0.2206061082955423,
83: 0.057572114707332415,
75: -2.4998375726165474,
76: -2.7954210713027443,
77: 3.3710663208638567,
84: 0.054257566315458174
};
F[0] = input[0];
F[1] = input[1];
F[2] = input[2];
F[3] = input[3];
F[4] = input[4];
F[5] = F[6];F[6] = F[7];F[6] += F[0] * F[8];F[6] += F[1] * F[9];F[6] += F[2] * F[10];F[6] += F[3] * F[11];F[6] += F[4] * F[12];F[13] = (1 / (1 + Math.exp(-F[6])));F[14] = F[13] * (1 - F[13]);
F[15] = F[16];F[16] = F[17];F[16] += F[0] * F[18];F[16] += F[1] * F[19];F[16] += F[2] * F[20];F[16] += F[3] * F[21];F[16] += F[4] * F[22];F[23] = (1 / (1 + Math.exp(-F[16])));F[24] = F[23] * (1 - F[23]);
F[25] = F[26];F[26] = F[27];F[26] += F[0] * F[28];F[26] += F[1] * F[29];F[26] += F[2] * F[30];F[26] += F[3] * F[31];F[26] += F[4] * F[32];F[33] = (1 / (1 + Math.exp(-F[26])));F[34] = F[33] * (1 - F[33]);
F[35] = F[36];F[36] = F[37];F[36] += F[0] * F[38];F[36] += F[1] * F[39];F[36] += F[2] * F[40];F[36] += F[3] * F[41];F[36] += F[4] * F[42];F[43] = (1 / (1 + Math.exp(-F[36])));F[44] = F[43] * (1 - F[43]);
F[45] = F[46];F[46] = F[47];F[46] += F[0] * F[48];F[46] += F[1] * F[49];F[46] += F[2] * F[50];F[46] += F[3] * F[51];F[46] += F[4] * F[52];F[53] = (1 / (1 + Math.exp(-F[46])));F[54] = F[53] * (1 - F[53]);
F[55] = F[56];F[56] = F[57];F[56] += F[13] * F[58];F[56] += F[23] * F[59];F[56] += F[33] * F[60];F[56] += F[43] * F[61];F[56] += F[53] * F[62];F[63] = (1 / (1 + Math.exp(-F[56])));F[64] = F[63] * (1 - F[63]);
F[65] = F[66];F[66] = F[67];F[66] += F[13] * F[68];F[66] += F[23] * F[69];F[66] += F[33] * F[70];F[66] += F[43] * F[71];F[66] += F[53] * F[72];F[73] = (1 / (1 + Math.exp(-F[66])));F[74] = F[73] * (1 - F[73]);
F[75] = F[76];F[76] = F[77];F[76] += F[13] * F[78];F[76] += F[23] * F[79];F[76] += F[33] * F[80];F[76] += F[43] * F[81];F[76] += F[53] * F[82];F[83] = (1 / (1 + Math.exp(-F[76])));F[84] = F[83] * (1 - F[83]);
var output = [];
output[0] = F[63];
output[1] = F[73];
output[2] = F[83];
return output;
}
while (true)  // keep on taking readings
{
  // take readings from each of the five ultrasonic sensors
  front_left=analogRead(A2);
  front_right=analogRead(A3);
  left=analogRead(A4);
  right=analogRead(A5);
  back=analogRead(A6);
  // if the sensors are all reading zero, no point
  // in calling the neural net
  if (front_left>0.2)||(front_right>0.2)||+(left>0.2)||(right>0.2)||(back>0.2){
    // create the input array from the sensor readings
    input =[front_left,front_right,left,right,back];
    output=calculate(input); // call the neural net
    sine = 2*Math.PI*((2*output[0])-1);   // convert the 0-1 output_0 to sine value
    cosine = 2*Math.PI*((2*output[1])-1); // convert the 0-1 output_1 to cosine value
    distance = output[2]*20;  // convert the 0-1 output_2 to actual distance
    x = cosine * distance;  // calculate the x co-ordinate
    y = sine * distance; // calculate the y co-ordinate
    console.log("," + x + "," + y);  // output the x,y co-ordinates to the console
  }
}
