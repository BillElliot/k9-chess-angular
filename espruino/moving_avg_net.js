/*

This simple program calculates the x and y co-ordinates
of the ultrasonic transmitter relative to the centre of K9
and send them to node-RED on the Raspberry Pi via USB cable.

It uses a standalone feed forward neural net
generated by the Synaptic.JS library.

It captures the data from the five ultrasonic sensors
every 6ms and maintains a moving average of their last 20 readings
(a period of 120ms)

Every 120ms the latest moving average value for all five sensors
is fed into the neural net to calculate three values between
zero and one.

These are then translated to the sine, cosine and
distance of the transmitter.

Simple trigonometry is then used to translate those values
to x and y co-ordinates relative to the centre of K9.

Program is designed to runs on Espruino microcontroller, but will also run
with simulated readings and outputs
for testing purposes using node.js via the command

usage: node moving_average_net [-s]
	options:
		-s 		run in simulation mode

Published under Creative Commons
Richard Hopkins, 14th October 2017

*/

// if -s is used to start script, then run in simulation mode
var sim = false;
if(process.argv.indexOf("-s") != -1){
	sim = true;
	console.log("Simulating sensors");
	}

var sensor_data = [];  // initialise sensor array that will hold objects
// list of sensor names
var sensor_names = ["front_left","front_right","left","right","back"];
// list of Espruino pins that correspond to the names
var pins = ["A2","A3","A4","A5","A6"];


var sensors = sensor_names.length;  // how many sensors do we have?
var readings = 20; // the number here must match the length of the readings array

/*
Initialise sensor array objects

This loop creates an object for each sensor, providing each object with
name, pin identifier and an empty set of readings
These are initialised at zero as K9 will not respond until the
moving average on one of the sensors exceeds 0.2; this therefore gives
the moving average some time to remove noise before K9 moves.

Two methods are created:

	mov_avg			calculates the average reading of the sensor object

	make_reading	adds a new reading to the end of the array and
					removes the oldest reading from the front -
					this means that mov_avg will calculate a moving average
					for that sensor object

*/

for (i=0;i<sensors;i++){
  sensor_data[i] = {
  	name: sensor_names[i], // sensor name
  	pin: pins[i], // sensor pin
  	reading: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // initialise readings array
  	mov_avg: function() {
  		var sum = 0;
  		for (var j in this.reading) sum += this.reading[j];  // calculate array total
  		return sum/readings  // return the moving average
  		},
  	make_reading: function(value) {
  		this.reading.push(value);  // push new value onto end of array
  		this.reading.splice(0,1);  // remove first value from array
  	}
  }
//  for (j=0;j<readings;j++){sensor_data[i].reading[j] = i*j;}
}

// neural net function that returns an x,y co-ordinates object
// based on the moving average readings from five sensors
function calculate(input) {
F = {
0: 0.16528572518,
1: 0.16699473563,
2: 0.19824521248,
3: 0.19336232547,
4: 0.15991454947,
13: 0.8932046931895035,
5: 1.7847067482038588,
6: 2.123901792468171,
7: -35.90827869164514,
8: 68.16002491856413,
9: 19.679127376567674,
10: 3.4291644194136164,
11: 89.4106961356289,
12: 34.472483402929754,
14: 0.09539006925374845,
58: -21.945141329704754,
68: -7.040865768744483,
78: -1.5000704306954435,
23: 0.9073504455064301,
15: 1.7051128767325263,
16: 2.2817046099866194,
17: -28.77104743984869,
18: 43.72362935353154,
19: 1.4127237744201968,
20: 87.41079249552176,
21: 0.48639559907242863,
22: 38.559700107890215,
24: 0.08406561454571294,
59: 20.749926854915866,
69: -5.703976090729581,
79: -3.6947897773330802,
33: 0.7365460929145874,
25: 0.971014107539875,
26: 1.0280933906628542,
27: 32.76651909221584,
28: -149.75223065722227,
29: -78.93971528453746,
30: -4.325653240247082,
31: 0.391635118645311,
32: 43.63778415344155,
34: 0.19404594592684338,
60: -4.214589549036702,
70: -6.75989422197201,
80: 0.353125540117511,
43: 0.9138069113725101,
35: 2.2606694512316934,
36: 2.3610292963124633,
37: -4.6254624603393895,
38: 0.4321294395493321,
39: 10.462152686114322,
40: -1.28954086594442,
41: 27.839761162958904,
42: 0.2551368421005903,
44: 0.07876384010034354,
61: -9.909990659029626,
71: 7.657495277252159,
81: -2.1384426672987393,
53: 0.5130552592525597,
45: 0.057831708754288336,
46: 0.05223290925742319,
47: -12.32849003526486,
48: 53.3112174468019,
49: 46.93450002541289,
50: 3.933893140800955,
51: -1.3610059244239483,
52: -29.921738457515236,
54: 0.24982956020584846,
62: -3.234370678324734,
72: -2.8435237716709016,
82: 0.42830345699084077,
63: 0.5035156049687228,
55: -0.32130179138580495,
56: 0.014062651620663225,
57: 14.605665153004754,
64: 0.24998764052170389,
73: 0.3285535310819797,
65: -0.09546114827149688,
66: -0.7147345133646377,
67: 10.189854736303543,
74: 0.2206061082955423,
83: 0.057572114707332415,
75: -2.4998375726165474,
76: -2.7954210713027443,
77: 3.3710663208638567,
84: 0.054257566315458174
};
F[0] = input[0];
F[1] = input[1];
F[2] = input[2];
F[3] = input[3];
F[4] = input[4];
F[5] = F[6];F[6] = F[7];F[6] += F[0] * F[8];F[6] += F[1] * F[9];F[6] += F[2] * F[10];F[6] += F[3] * F[11];F[6] += F[4] * F[12];F[13] = (1 / (1 + Math.exp(-F[6])));F[14] = F[13] * (1 - F[13]);
F[15] = F[16];F[16] = F[17];F[16] += F[0] * F[18];F[16] += F[1] * F[19];F[16] += F[2] * F[20];F[16] += F[3] * F[21];F[16] += F[4] * F[22];F[23] = (1 / (1 + Math.exp(-F[16])));F[24] = F[23] * (1 - F[23]);
F[25] = F[26];F[26] = F[27];F[26] += F[0] * F[28];F[26] += F[1] * F[29];F[26] += F[2] * F[30];F[26] += F[3] * F[31];F[26] += F[4] * F[32];F[33] = (1 / (1 + Math.exp(-F[26])));F[34] = F[33] * (1 - F[33]);
F[35] = F[36];F[36] = F[37];F[36] += F[0] * F[38];F[36] += F[1] * F[39];F[36] += F[2] * F[40];F[36] += F[3] * F[41];F[36] += F[4] * F[42];F[43] = (1 / (1 + Math.exp(-F[36])));F[44] = F[43] * (1 - F[43]);
F[45] = F[46];F[46] = F[47];F[46] += F[0] * F[48];F[46] += F[1] * F[49];F[46] += F[2] * F[50];F[46] += F[3] * F[51];F[46] += F[4] * F[52];F[53] = (1 / (1 + Math.exp(-F[46])));F[54] = F[53] * (1 - F[53]);
F[55] = F[56];F[56] = F[57];F[56] += F[13] * F[58];F[56] += F[23] * F[59];F[56] += F[33] * F[60];F[56] += F[43] * F[61];F[56] += F[53] * F[62];F[63] = (1 / (1 + Math.exp(-F[56])));F[64] = F[63] * (1 - F[63]);
F[65] = F[66];F[66] = F[67];F[66] += F[13] * F[68];F[66] += F[23] * F[69];F[66] += F[33] * F[70];F[66] += F[43] * F[71];F[66] += F[53] * F[72];F[73] = (1 / (1 + Math.exp(-F[66])));F[74] = F[73] * (1 - F[73]);
F[75] = F[76];F[76] = F[77];F[76] += F[13] * F[78];F[76] += F[23] * F[79];F[76] += F[33] * F[80];F[76] += F[43] * F[81];F[76] += F[53] * F[82];F[83] = (1 / (1 + Math.exp(-F[76])));F[84] = F[83] * (1 - F[83]);
var output = [];
output[0] = F[63];
output[1] = F[73];
output[2] = F[83];
sine = 2*Math.PI*((2*output[0])-1);   // convert the 0-1 output_0 to sine value
cosine = 2*Math.PI*((2*output[1])-1); // convert the 0-1 output_1 to cosine value
distance = output[2]*20;  // convert the 0-1 output_2 to actual distance
var coordinates={
	x: cosine * distance,  // calculate the x co-ordinate
	y: sine * distance // calculate the y co-ordinate
	};
return coordinates;
}

function takeSensorReadings(){
	for (i=0;i<sensors;i++){
		if (!sim) {sensor_data[i].make_reading(analogRead(sensor_data[i].pin));}
		else {sensor_data[i].make_reading(Math.random()*0.35);} // simulate analog read
		}
}

function sendNRMsg(type,sensor,reading) {
  message = String('{"type":"'+type+'","sensor":"'+sensor+'","reading":"'+reading+'"}!');
  if (!sim){USB.print(message);}
  else {console.log(message);}
}

function sendXYtoNR(){
	var input=[];
	var transmitting=false
	for (i=0;i<sensors;i++){
		input[i] = sensor_data[i].mov_avg();
		if (input[i]>0.2) {transmitting=true};
		}
	if (transmitting==true){
		xy=calculate(input); // call the neural net
		sendNRMsg("sensor","ultrasonic",xy.x + "|" + xy.y);
		}
}

// take sensor readings every 6ms
var scan=setInterval(takeSensorReadings,6);
// send message to node-RED every 120ms
var send=setInterval(sendXYtoNR,120);
