/*

This simple program calculates the x and y co-ordinates
of the ultrasonic transmitter relative to the centre of K9
and send them to node-RED on the Raspberry Pi via USB cable.

It uses a standalone feed forward neural net
generated by the Synaptic.JS library.

It captures the data from the five ultrasonic sensors
every 6ms and maintains a moving average of their last 20 readings
(a period of 120ms)

Every 120ms the latest moving average value for all five sensors
is fed into the neural net to calculate four values between
zero and one.

These are then translated to the sine, cosine, status and
distance of the transmitter.  Status describes whether 
there is a transmission in progress

Simple trigonometry is then used to translate those values
to x and y co-ordinates relative to the centre of K9.

Program is designed to runs on Espruino microcontroller.

Published under The Unlicense
Richard Hopkins, 9th February 2020

*/

// neural net function that returns an x,y co-ordinates object
// based on the moving average readings from five sensors

function calculate(input) {
F = {
0: 0.14892805371,
1: 0.99977111467,
2: 0.14721904325,
3: 0.17041275654,
4: 0.99977111467,
13: 3.641194136926438e-7,
5: -11.303724245427365,
6: -14.825783599394798,
7: -2.6686434086060467,
8: -2.6408217531471756,
9: -3.960726773462393,
10: -0.8883490899524019,
11: -2.067254640244159,
12: -7.322635103750286,
14: 3.6411928110969637e-7,
48: -0.8464795489428503,
57: 2.8147861485086993,
66: -0.34501284382394853,
75: 0.28704105151329806,
23: 8.351334655378778e-14,
15: -21.596191399215193,
16: -30.11376993685916,
17: 3.977766799548083,
18: -7.5492578808352455,
19: -9.652132752886253,
20: -1.2236471366063897,
21: -3.4975111302878674,
22: -22.546312778735828,
24: 8.351334655378082e-14,
49: 0.0630248416816693,
58: 12.405981960029557,
67: -0.6762538718557071,
76: 0.13780735284450052,
33: 0.9000524113258577,
25: 1.9802597108174576,
26: 2.197807061101088,
27: 1.6645051880463588,
28: -0.035997909028303604,
29: 0.23685782513634204,
30: 2.6630988614906217,
31: 0.48835413804163164,
32: -0.1734783983489118,
34: 0.08995806819236679,
50: 0.6631910542351792,
59: -1.7359524291465394,
68: 1.8732956194143988,
77: -0.9154766256165803,
43: 0.8848885163038385,
35: 2.417445581155865,
36: 2.0395605845741733,
37: 2.983451590214394,
38: -0.871750855153237,
39: -0.46509071290938947,
40: -2.916603465637454,
41: 0.3223519155803731,
42: 0.025665898051858583,
44: 0.10186083001742988,
51: -1.6511984442788668,
60: 1.2730612908668282,
69: 0.13575299819582815,
78: 0.2430999083212807,
52: 0.5079751795918216,
45: -0.035892219377093415,
46: 0.03190342410966718,
47: 0.8951649265809111,
53: 0.2499363965104782,
61: 0.6454863019729848,
54: 0.6790708009690698,
55: 0.5992570036202081,
56: 1.03570472334776,
62: 0.22883373593822548,
70: 0.670464216286036,
63: 0.6739272375326942,
64: 0.7102853845082739,
65: -1.0950504719029643,
71: 0.22094195096598754,
79: 0.5700544176642434,
72: 0.3103376672437691,
73: 0.282073177886461,
74: 0.8911842279310762,
80: 0.24509237856572375
};
F[0] = input[0];
F[1] = input[1];
F[2] = input[2];
F[3] = input[3];
F[4] = input[4];
F[5] = F[6];F[6] = F[7];F[6] += F[0] * F[8];F[6] += F[1] * F[9];F[6] += F[2] * F[10];F[6] += F[3] * F[11];F[6] += F[4] * F[12];F[13] = (1 / (1 + Math.exp(-F[6])));F[14] = F[13] * (1 - F[13]);
F[15] = F[16];F[16] = F[17];F[16] += F[0] * F[18];F[16] += F[1] * F[19];F[16] += F[2] * F[20];F[16] += F[3] * F[21];F[16] += F[4] * F[22];F[23] = (1 / (1 + Math.exp(-F[16])));F[24] = F[23] * (1 - F[23]);
F[25] = F[26];F[26] = F[27];F[26] += F[0] * F[28];F[26] += F[1] * F[29];F[26] += F[2] * F[30];F[26] += F[3] * F[31];F[26] += F[4] * F[32];F[33] = (1 / (1 + Math.exp(-F[26])));F[34] = F[33] * (1 - F[33]);
F[35] = F[36];F[36] = F[37];F[36] += F[0] * F[38];F[36] += F[1] * F[39];F[36] += F[2] * F[40];F[36] += F[3] * F[41];F[36] += F[4] * F[42];F[43] = (1 / (1 + Math.exp(-F[36])));F[44] = F[43] * (1 - F[43]);
F[45] = F[46];F[46] = F[47];F[46] += F[13] * F[48];F[46] += F[23] * F[49];F[46] += F[33] * F[50];F[46] += F[43] * F[51];F[52] = (1 / (1 + Math.exp(-F[46])));F[53] = F[52] * (1 - F[52]);
F[54] = F[55];F[55] = F[56];F[55] += F[13] * F[57];F[55] += F[23] * F[58];F[55] += F[33] * F[59];F[55] += F[43] * F[60];F[61] = (1 / (1 + Math.exp(-F[55])));F[62] = F[61] * (1 - F[61]);
F[63] = F[64];F[64] = F[65];F[64] += F[13] * F[66];F[64] += F[23] * F[67];F[64] += F[33] * F[68];F[64] += F[43] * F[69];F[70] = (1 / (1 + Math.exp(-F[64])));F[71] = F[70] * (1 - F[70]);
F[72] = F[73];F[73] = F[74];F[73] += F[13] * F[75];F[73] += F[23] * F[76];F[73] += F[33] * F[77];F[73] += F[43] * F[78];F[79] = (1 / (1 + Math.exp(-F[73])));F[80] = F[79] * (1 - F[79]);
var output = [];
output[0] = F[52];
output[1] = F[61];
output[2] = F[70];
output[3] = F[79];
sine = 2*Math.PI*((2*output[0])-1);   // convert the 0-1 output_0 back to original sine value
cosine = 2*Math.PI*((2*output[1])-1); // convert the 0-1 output_1 back to original cosine value
var bearings={
	distance: output[3]*3,  // convert the 0-1 output_3 to actual distance in metres
	angle: Math.atan2(sine,cosine),			 // convert sine/cosine back into angle in radians
    status: output[2]
	};
return bearings;
}

function takeSensorReadings(){
	for (i=0;i<sensors;i++){
		sensor_data[i].make_reading(analogRead(sensor_data[i].pin));
		}
}

function sendNRMsg(type,sensor,distance,angle) {
  message = String('{"type":"'+type+'","sensor":"'+sensor+'","distance":"'+distance+'","angle":"'+angle+'"}');
  USB.println(message);
}

function sendXYtoNR(){
	var input=[];
	var transmitting=false;
    var bearings = {
      distance: 0,
      angle: 0};
	for (i=0;i<sensors;i++){
		input[i] = sensor_data[i].mov_avg();
		if (input[i]>0.2) {transmitting=true;}
		}
	if (transmitting===true){
		bearings=calculate(input); // call the neural net to retried distance and angle
		bearings.angle = Math.round(bearings.angle*180/Math.PI); // calculate degrees from radians
    }   sendNRMsg("sensor","ultrasonic",bearings.distance.toString(),bearings.angle.toString());
}

function onInit(){
  // set up USB serial port
  USB.setup(115200,{
	  bytesize:8,    // How many data bits
	  stopbits:1,    // Number of stop bits to use
	  });
  sensor_data = [];  // initialise sensor array that will hold objects
  // list of sensor names
  sensor_names = ["front_left","front_right","left","right","back"];
  // list of Espruino pins that correspond to the names
  pins = ["A2","A3","A4","A5","A6"];
  sensors = sensor_names.length;  // how many sensors do we have?
  readings = 20; // the number here must match the length of the readings array
  /*
  Initialise sensor array objects

  This loop creates an object for each sensor, providing each object with
  name, pin identifier and an empty set of readings
  These are initialised at zero as K9 will not respond until the
  moving average on one of the sensors exceeds 0.2; this therefore gives
  the moving average some time to remove noise before K9 moves.

  Two methods are created:

	  mov_avg			calculates the average reading of the sensor object

	  make_reading	adds a new reading to the end of the array and
					removes the oldest reading from the front -
					this means that mov_avg will calculate a moving average
					for that sensor object

  */
  for (i=0;i<sensors;i++){
    sensor_data[i] = {
  	  name: sensor_names[i], // sensor name
  	  pin: pins[i], // sensor pin
  	  reading: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // initialise readings array
  	  mov_avg: function() {
  		  var sum = 0;
  		  for (var j in this.reading) {sum += this.reading[j];}  // calculate array total
  		  return sum/readings;  // return the moving average
  		  },
  	  make_reading: function(value) {
  		  this.reading.push(value);  // push new value onto end of array
  		  this.reading.splice(0,1);  // remove first value from array
  	  }
    }
  ;}
  // take sensor readings every 6ms
  var scan=setInterval(takeSensorReadings,6);
  // send message to node-RED every 120ms
  var send=setInterval(sendXYtoNR,120);
}
